{"ast":null,"code":"\"use strict\";\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isIOS = exports.useThumbOverlap = exports.assertUnreachable = exports.voidFn = exports.getTrackBackground = exports.replaceAt = exports.schd = exports.translate = exports.getClosestThumbIndex = exports.translateThumbs = exports.getPaddingAndBorder = exports.getMargin = exports.checkInitialOverlap = exports.checkValuesAgainstBoundaries = exports.checkBoundaries = exports.isVertical = exports.relativeValue = exports.normalizeValue = exports.isStepDivisible = exports.isTouchEvent = exports.getStepDecimals = void 0;\nvar react_1 = require(\"react\");\nvar types_1 = require(\"./types\");\nvar getStepDecimals = function (step) {\n  var decimals = step.toString().split(\".\")[1];\n  return decimals ? decimals.length : 0;\n};\nexports.getStepDecimals = getStepDecimals;\nfunction isTouchEvent(event) {\n  return event.touches && event.touches.length || event.changedTouches && event.changedTouches.length;\n}\nexports.isTouchEvent = isTouchEvent;\nfunction isStepDivisible(min, max, step) {\n  var res = (max - min) / step;\n  var precision = 8;\n  var roundedRes = Number(res.toFixed(precision));\n  return parseInt(roundedRes.toString(), 10) === roundedRes;\n}\nexports.isStepDivisible = isStepDivisible;\nfunction normalizeValue(value, index, min, max, step, allowOverlap, values) {\n  var BIG_NUM = 10e10;\n  value = Math.round(value * BIG_NUM) / BIG_NUM;\n  if (!allowOverlap) {\n    var prev = values[index - 1];\n    var next = values[index + 1];\n    if (prev && prev > value) return prev;\n    if (next && next < value) return next;\n  }\n  if (value > max) return max;\n  if (value < min) return min;\n  // `remainder` is a difference between the given value and a full step value\n  // that is closest lower to the given value and is in the range between the min value\n  // and the given value\n  var remainder = Math.floor(value * BIG_NUM - min * BIG_NUM) % Math.floor(step * BIG_NUM);\n  var closestLowerNum = Math.floor(value * BIG_NUM - Math.abs(remainder));\n  var rounded = remainder === 0 ? value : closestLowerNum / BIG_NUM;\n  // Values with a remainder `< step/2` are rounded to the closest lower value\n  // while values with a remainder `= > step/2` are rounded to the closest bigger value\n  var res = Math.abs(remainder / BIG_NUM) < step / 2 ? rounded : rounded + step;\n  var decimalPlaces = (0, exports.getStepDecimals)(step);\n  return parseFloat(res.toFixed(decimalPlaces));\n}\nexports.normalizeValue = normalizeValue;\nfunction relativeValue(value, min, max) {\n  return (value - min) / (max - min);\n}\nexports.relativeValue = relativeValue;\nfunction isVertical(direction) {\n  return direction === types_1.Direction.Up || direction === types_1.Direction.Down;\n}\nexports.isVertical = isVertical;\nfunction checkBoundaries(value, min, max) {\n  if (min >= max) {\n    throw new RangeError(\"min (\".concat(min, \") is equal/bigger than max (\").concat(max, \")\"));\n  }\n  if (value < min) {\n    throw new RangeError(\"value (\".concat(value, \") is smaller than min (\").concat(min, \")\"));\n  }\n  if (value > max) {\n    throw new RangeError(\"value (\".concat(value, \") is bigger than max (\").concat(max, \")\"));\n  }\n}\nexports.checkBoundaries = checkBoundaries;\nfunction checkValuesAgainstBoundaries(value, min, max) {\n  if (value < min) {\n    // set selectedValue to min\n    return min;\n  }\n  if (value > max) {\n    // set selectedValue to max\n    return max;\n  } else {\n    return value;\n  }\n}\nexports.checkValuesAgainstBoundaries = checkValuesAgainstBoundaries;\nfunction checkInitialOverlap(values) {\n  if (values.length < 2) return;\n  if (!values.slice(1).every(function (item, i) {\n    return values[i] <= item;\n  })) {\n    throw new RangeError(\"values={[\".concat(values, \"]} needs to be sorted when allowOverlap={false}\"));\n  }\n}\nexports.checkInitialOverlap = checkInitialOverlap;\nfunction getMargin(element) {\n  var style = window.getComputedStyle(element);\n  return {\n    top: parseInt(style[\"margin-top\"], 10),\n    bottom: parseInt(style[\"margin-bottom\"], 10),\n    left: parseInt(style[\"margin-left\"], 10),\n    right: parseInt(style[\"margin-right\"], 10)\n  };\n}\nexports.getMargin = getMargin;\nfunction getPaddingAndBorder(element) {\n  var style = window.getComputedStyle(element);\n  return {\n    top: parseInt(style[\"padding-top\"], 10) + parseInt(style[\"border-top-width\"], 10),\n    bottom: parseInt(style[\"padding-bottom\"], 10) + parseInt(style[\"border-bottom-width\"], 10),\n    left: parseInt(style[\"padding-left\"], 10) + parseInt(style[\"border-left-width\"], 10),\n    right: parseInt(style[\"padding-right\"], 10) + parseInt(style[\"border-right-width\"], 10)\n  };\n}\nexports.getPaddingAndBorder = getPaddingAndBorder;\nfunction translateThumbs(elements, offsets, rtl) {\n  var inverter = rtl ? -1 : 1;\n  elements.forEach(function (element, index) {\n    return translate(element, inverter * offsets[index].x, offsets[index].y);\n  });\n}\nexports.translateThumbs = translateThumbs;\n/**\n * Util function for calculating the index of the thumb that is closes to a given position\n * @param thumbs - array of Thumb element to calculate the distance from\n * @param clientX - target x position (mouse/touch)\n * @param clientY - target y position (mouse/touch)\n * @param direction - the direction of the track\n */\nfunction getClosestThumbIndex(thumbs, clientX, clientY, direction) {\n  var thumbIndex = 0;\n  var minThumbDistance = getThumbDistance(thumbs[0], clientX, clientY, direction);\n  for (var i = 1; i < thumbs.length; i++) {\n    var thumbDistance = getThumbDistance(thumbs[i], clientX, clientY, direction);\n    if (thumbDistance < minThumbDistance) {\n      minThumbDistance = thumbDistance;\n      thumbIndex = i;\n    }\n  }\n  return thumbIndex;\n}\nexports.getClosestThumbIndex = getClosestThumbIndex;\nfunction translate(element, x, y) {\n  element.style.transform = \"translate(\".concat(x, \"px, \").concat(y, \"px)\");\n}\nexports.translate = translate;\n// adapted from https://github.com/alexreardon/raf-schd\nvar schd = function (fn) {\n  var lastArgs = [];\n  var frameId = null;\n  var wrapperFn = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    lastArgs = args;\n    if (frameId) {\n      return;\n    }\n    frameId = requestAnimationFrame(function () {\n      frameId = null;\n      fn.apply(void 0, lastArgs);\n    });\n  };\n  return wrapperFn;\n};\nexports.schd = schd;\nfunction replaceAt(values, index, value) {\n  var ret = values.slice(0);\n  ret[index] = value;\n  return ret;\n}\nexports.replaceAt = replaceAt;\nfunction getTrackBackground(_a) {\n  var values = _a.values,\n    colors = _a.colors,\n    min = _a.min,\n    max = _a.max,\n    _b = _a.direction,\n    direction = _b === void 0 ? types_1.Direction.Right : _b,\n    _c = _a.rtl,\n    rtl = _c === void 0 ? false : _c;\n  if (rtl && direction === types_1.Direction.Right) {\n    direction = types_1.Direction.Left;\n  } else if (rtl && types_1.Direction.Left) {\n    direction = types_1.Direction.Right;\n  }\n  // sort values ascending\n  var progress = values.slice(0).sort(function (a, b) {\n    return a - b;\n  }).map(function (value) {\n    return (value - min) / (max - min) * 100;\n  });\n  var middle = progress.reduce(function (acc, point, index) {\n    return \"\".concat(acc, \", \").concat(colors[index], \" \").concat(point, \"%, \").concat(colors[index + 1], \" \").concat(point, \"%\");\n  }, \"\");\n  return \"linear-gradient(\".concat(direction, \", \").concat(colors[0], \" 0%\").concat(middle, \", \").concat(colors[colors.length - 1], \" 100%)\");\n}\nexports.getTrackBackground = getTrackBackground;\nfunction voidFn() {}\nexports.voidFn = voidFn;\nfunction assertUnreachable(x) {\n  throw new Error(\"Didn't expect to get here\");\n}\nexports.assertUnreachable = assertUnreachable;\n/**\n * Util function for grabbing the true largest width of a thumb\n * including the label\n * @param thumbEl - Thumb element to grab the largest width from\n * @param value - Thumb value, not label value\n * @param separator - Label separator value\n */\nvar getThumbWidth = function (thumbEl, value, separator, decimalPlaces, valueToLabel) {\n  if (valueToLabel === void 0) {\n    valueToLabel = function (value) {\n      return value;\n    };\n  }\n  var width = Math.ceil(__spreadArray([thumbEl], Array.from(thumbEl.children), true).reduce(function (width, el) {\n    var elWidth = Math.ceil(el.getBoundingClientRect().width);\n    /**\n     * If a label contains a merged label value, it won't return the true\n     * label width for that Thumb. Clone the label and change the value\n     * to that individual Thumb value in order to grab the true width.\n     */\n    if (el.innerText && el.innerText.includes(separator) && el.childElementCount === 0) {\n      var elClone = el.cloneNode(true);\n      elClone.innerHTML = valueToLabel(value.toFixed(decimalPlaces));\n      elClone.style.visibility = \"hidden\";\n      document.body.appendChild(elClone);\n      elWidth = Math.ceil(elClone.getBoundingClientRect().width);\n      document.body.removeChild(elClone);\n    }\n    return elWidth > width ? elWidth : width;\n  }, thumbEl.getBoundingClientRect().width));\n  return width;\n};\n/**\n * Bulk of logic for thumb overlaps\n * Consider a scenario with 5 thumbs;\n * Thumb 1 overlaps with thumb 0 and thumb 2\n * Thumb 2 overlaps with thumb 3\n * We need an array that contains [0, 1, 2, 3]\n * The function needs to return the directly overlapping thumbs\n * and all thumbs overlapping linked to those and so on\n * @param index - Thumb index calculating overlaps for\n * @param offsets - Current Array of Thumb offsets for Range\n * @param thumbs - Array of Thumb elements\n * @param values - Array of Thumb values\n * @param separator - String separator for merged label values\n * @returns overlaps - Array of all overlapping thumbs from the index\n */\nvar getOverlaps = function (index, offsets, thumbs, values, separator, decimalPlaces, valueToLabel) {\n  if (valueToLabel === void 0) {\n    valueToLabel = function (value) {\n      return value;\n    };\n  }\n  var overlaps = [];\n  /**\n   * Recursive function for building the overlaps Array\n   * If an overlap is found, find the overlaps for that overlap\n   * @param thumbIndex current Thumb index to find overlaps from\n   */\n  var buildOverlaps = function (thumbIndex) {\n    var thumbXWidth = getThumbWidth(thumbs[thumbIndex], values[thumbIndex], separator, decimalPlaces, valueToLabel);\n    var thumbX = offsets[thumbIndex].x;\n    /**\n     * Iterate through the Thumb offsets, if there is a match\n     * add the thumbIndex and siblingIndex to the overlaps Array\n     *\n     * Then build overlaps from the overlapping siblingIndex\n     */\n    offsets.forEach(function (_a, siblingIndex) {\n      var siblingX = _a.x;\n      var siblingWidth = getThumbWidth(thumbs[siblingIndex], values[siblingIndex], separator, decimalPlaces, valueToLabel);\n      if (thumbIndex !== siblingIndex && (thumbX >= siblingX && thumbX <= siblingX + siblingWidth || thumbX + thumbXWidth >= siblingX && thumbX + thumbXWidth <= siblingX + siblingWidth)) {\n        if (!overlaps.includes(siblingIndex)) {\n          overlaps.push(thumbIndex);\n          overlaps.push(siblingIndex);\n          overlaps = __spreadArray(__spreadArray([], overlaps, true), [thumbIndex, siblingIndex], false);\n          buildOverlaps(siblingIndex);\n        }\n      }\n    });\n  };\n  buildOverlaps(index);\n  // Sort and remove duplicates from the built overlaps\n  return Array.from(new Set(overlaps.sort()));\n};\n/**\n * A custom React Hook for calculating whether a thumb overlaps\n * another and whether labels could/should merge.\n * @param rangeRef - React ref value of Range component\n * @param values - current Range values Array\n * @param index - thumb index\n * @param step - step value, used to calculate the number of decimal places\n * @param separator - string to separate thumb values\n * @returns label value + styling for thumb label\n */\nvar useThumbOverlap = function (rangeRef, values, index, step, separator, valueToLabel) {\n  if (step === void 0) {\n    step = 0.1;\n  }\n  if (separator === void 0) {\n    separator = \" - \";\n  }\n  if (valueToLabel === void 0) {\n    valueToLabel = function (value) {\n      return value;\n    };\n  }\n  var decimalPlaces = (0, exports.getStepDecimals)(step);\n  // Create initial label style and value. Label value defaults to thumb value\n  var _a = (0, react_1.useState)({}),\n    labelStyle = _a[0],\n    setLabelStyle = _a[1];\n  var _b = (0, react_1.useState)(valueToLabel(values[index].toFixed(decimalPlaces))),\n    labelValue = _b[0],\n    setLabelValue = _b[1];\n  // When the rangeRef or values change, update the Thumb label values and styling\n  (0, react_1.useEffect)(function () {\n    if (rangeRef) {\n      var thumbs = rangeRef.getThumbs();\n      if (thumbs.length < 1) return;\n      var newStyle = {};\n      var offsets_1 = rangeRef.getOffsets();\n      /**\n       * Get any overlaps for the given Thumb index. This must return all linked\n       * Thumbs. So if there are 4 Thumbs and Thumbs 2, 3 and 4 overlap. If we are\n       * getting the overlaps for Thumb 1 and it overlaps only Thumb 2, we must get\n       * 2, 3 and 4 also.\n       */\n      var overlaps = getOverlaps(index, offsets_1, thumbs, values, separator, decimalPlaces, valueToLabel);\n      // Set a default label value of the Thumb value\n      var labelValue_1 = valueToLabel(values[index].toFixed(decimalPlaces));\n      /**\n       * If there are overlaps for the Thumb, we need to calculate the correct\n       * Label value along with the relevant styling. We only want to show a Label\n       * for the left most Thumb in an overlapping set.\n       * All other Thumbs will be set to display: none.\n       */\n      if (overlaps.length) {\n        /**\n         * Get an Array of the offsets for the overlapping Thumbs\n         * This is so we can determine if the Thumb we are looking at\n         * is the left most thumb in an overlapping set\n         */\n        var offsetsX = overlaps.reduce(function (a, c, i, s) {\n          return a.length ? __spreadArray(__spreadArray([], a, true), [offsets_1[s[i]].x], false) : [offsets_1[s[i]].x];\n        }, []);\n        /**\n         * If our Thumb is the left most Thumb, we can build a Label value\n         * and set the style for that Label\n         */\n        if (Math.min.apply(Math, offsetsX) === offsets_1[index].x) {\n          /**\n           * First calculate the Label value. To do this,\n           * grab all the values for the Thumbs in our overlaps.\n           * Then convert that to a Set and sort it whilst removing duplicates.\n           */\n          var labelValues_1 = [];\n          overlaps.forEach(function (thumb) {\n            labelValues_1.push(values[thumb].toFixed(decimalPlaces));\n          });\n          /**\n           *  Update the labelValue with the resulting Array\n           *  joined by our defined separator\n           */\n          labelValue_1 = Array.from(new Set(labelValues_1.sort(function (a, b) {\n            return parseFloat(a) - parseFloat(b);\n          }))).map(valueToLabel).join(separator);\n          /**\n           * Lastly, build the label styling. The label styling will\n           * position the label and apply a transform so that it's centered.\n           * We want the center point between the left edge of the left most Thumb\n           * and the right edge of the right most Thumb.\n           */\n          var first = Math.min.apply(Math, offsetsX);\n          var last = Math.max.apply(Math, offsetsX);\n          var lastWidth = thumbs[overlaps[offsetsX.indexOf(last)]].getBoundingClientRect().width;\n          newStyle.left = \"\".concat(Math.abs(first - (last + lastWidth)) / 2, \"px\");\n          newStyle.transform = \"translate(-50%, 0)\";\n        } else {\n          // If the Thumb isn't the left most Thumb, hide the Label!\n          newStyle.visibility = \"hidden\";\n        }\n      }\n      // Update the label value and style\n      setLabelValue(labelValue_1);\n      setLabelStyle(newStyle);\n    }\n  }, [rangeRef, values]);\n  return [labelValue, labelStyle];\n};\nexports.useThumbOverlap = useThumbOverlap;\n/**\n * Util function for calculating the distance of the center of a thumb\n * form a given mouse/touch target's position\n * @param thumbEl - Thumb element to calculate the distance from\n * @param clientX - target x position (mouse/touch)\n * @param clientY - target y position (mouse/touch)\n * @param direction - the direction of the track\n */\nfunction getThumbDistance(thumbEl, clientX, clientY, direction) {\n  var _a = thumbEl.getBoundingClientRect(),\n    left = _a.left,\n    top = _a.top,\n    width = _a.width,\n    height = _a.height;\n  return isVertical(direction) ? Math.abs(clientY - (top + height / 2)) : Math.abs(clientX - (left + width / 2));\n}\nvar isIOS = function () {\n  var _a;\n  // @ts-ignore\n  var platform = ((_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.platform) || navigator.platform;\n  return [\"iPad Simulator\", \"iPhone Simulator\", \"iPod Simulator\", \"iPad\", \"iPhone\", \"iPod\"].includes(platform) ||\n  // iPad on iOS 13 detection\n  navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document;\n};\nexports.isIOS = isIOS;","map":{"version":3,"names":["__spreadArray","to","from","pack","arguments","length","i","l","ar","Array","prototype","slice","call","concat","Object","defineProperty","exports","value","isIOS","useThumbOverlap","assertUnreachable","voidFn","getTrackBackground","replaceAt","schd","translate","getClosestThumbIndex","translateThumbs","getPaddingAndBorder","getMargin","checkInitialOverlap","checkValuesAgainstBoundaries","checkBoundaries","isVertical","relativeValue","normalizeValue","isStepDivisible","isTouchEvent","getStepDecimals","react_1","require","types_1","step","decimals","toString","split","event","touches","changedTouches","min","max","res","precision","roundedRes","Number","toFixed","parseInt","index","allowOverlap","values","BIG_NUM","Math","round","prev","next","remainder","floor","closestLowerNum","abs","rounded","decimalPlaces","parseFloat","direction","Direction","Up","Down","RangeError","every","item","element","style","window","getComputedStyle","top","bottom","left","right","elements","offsets","rtl","inverter","forEach","x","y","thumbs","clientX","clientY","thumbIndex","minThumbDistance","getThumbDistance","thumbDistance","transform","fn","lastArgs","frameId","wrapperFn","args","_i","requestAnimationFrame","apply","ret","_a","colors","_b","Right","_c","Left","progress","sort","a","b","map","middle","reduce","acc","point","Error","getThumbWidth","thumbEl","separator","valueToLabel","width","ceil","children","el","elWidth","getBoundingClientRect","innerText","includes","childElementCount","elClone","cloneNode","innerHTML","visibility","document","body","appendChild","removeChild","getOverlaps","overlaps","buildOverlaps","thumbXWidth","thumbX","siblingIndex","siblingX","siblingWidth","push","Set","rangeRef","useState","labelStyle","setLabelStyle","labelValue","setLabelValue","useEffect","getThumbs","newStyle","offsets_1","getOffsets","labelValue_1","offsetsX","c","s","labelValues_1","thumb","join","first","last","lastWidth","indexOf","height","platform","navigator","userAgentData","userAgent"],"sources":["/Users/win/Documents/FullStack/IBM/ecommerce-frontend/node_modules/react-range/lib/utils.js"],"sourcesContent":["\"use strict\";\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isIOS = exports.useThumbOverlap = exports.assertUnreachable = exports.voidFn = exports.getTrackBackground = exports.replaceAt = exports.schd = exports.translate = exports.getClosestThumbIndex = exports.translateThumbs = exports.getPaddingAndBorder = exports.getMargin = exports.checkInitialOverlap = exports.checkValuesAgainstBoundaries = exports.checkBoundaries = exports.isVertical = exports.relativeValue = exports.normalizeValue = exports.isStepDivisible = exports.isTouchEvent = exports.getStepDecimals = void 0;\nvar react_1 = require(\"react\");\nvar types_1 = require(\"./types\");\nvar getStepDecimals = function (step) {\n    var decimals = step.toString().split(\".\")[1];\n    return decimals ? decimals.length : 0;\n};\nexports.getStepDecimals = getStepDecimals;\nfunction isTouchEvent(event) {\n    return ((event.touches && event.touches.length) ||\n        (event.changedTouches && event.changedTouches.length));\n}\nexports.isTouchEvent = isTouchEvent;\nfunction isStepDivisible(min, max, step) {\n    var res = (max - min) / step;\n    var precision = 8;\n    var roundedRes = Number(res.toFixed(precision));\n    return parseInt(roundedRes.toString(), 10) === roundedRes;\n}\nexports.isStepDivisible = isStepDivisible;\nfunction normalizeValue(value, index, min, max, step, allowOverlap, values) {\n    var BIG_NUM = 10e10;\n    value = Math.round(value * BIG_NUM) / BIG_NUM;\n    if (!allowOverlap) {\n        var prev = values[index - 1];\n        var next = values[index + 1];\n        if (prev && prev > value)\n            return prev;\n        if (next && next < value)\n            return next;\n    }\n    if (value > max)\n        return max;\n    if (value < min)\n        return min;\n    // `remainder` is a difference between the given value and a full step value\n    // that is closest lower to the given value and is in the range between the min value\n    // and the given value\n    var remainder = Math.floor(value * BIG_NUM - min * BIG_NUM) % Math.floor(step * BIG_NUM);\n    var closestLowerNum = Math.floor(value * BIG_NUM - Math.abs(remainder));\n    var rounded = remainder === 0 ? value : closestLowerNum / BIG_NUM;\n    // Values with a remainder `< step/2` are rounded to the closest lower value\n    // while values with a remainder `= > step/2` are rounded to the closest bigger value\n    var res = Math.abs(remainder / BIG_NUM) < step / 2 ? rounded : rounded + step;\n    var decimalPlaces = (0, exports.getStepDecimals)(step);\n    return parseFloat(res.toFixed(decimalPlaces));\n}\nexports.normalizeValue = normalizeValue;\nfunction relativeValue(value, min, max) {\n    return (value - min) / (max - min);\n}\nexports.relativeValue = relativeValue;\nfunction isVertical(direction) {\n    return direction === types_1.Direction.Up || direction === types_1.Direction.Down;\n}\nexports.isVertical = isVertical;\nfunction checkBoundaries(value, min, max) {\n    if (min >= max) {\n        throw new RangeError(\"min (\".concat(min, \") is equal/bigger than max (\").concat(max, \")\"));\n    }\n    if (value < min) {\n        throw new RangeError(\"value (\".concat(value, \") is smaller than min (\").concat(min, \")\"));\n    }\n    if (value > max) {\n        throw new RangeError(\"value (\".concat(value, \") is bigger than max (\").concat(max, \")\"));\n    }\n}\nexports.checkBoundaries = checkBoundaries;\nfunction checkValuesAgainstBoundaries(value, min, max) {\n    if (value < min) {\n        // set selectedValue to min\n        return min;\n    }\n    if (value > max) {\n        // set selectedValue to max\n        return max;\n    }\n    else {\n        return value;\n    }\n}\nexports.checkValuesAgainstBoundaries = checkValuesAgainstBoundaries;\nfunction checkInitialOverlap(values) {\n    if (values.length < 2)\n        return;\n    if (!values.slice(1).every(function (item, i) { return values[i] <= item; })) {\n        throw new RangeError(\"values={[\".concat(values, \"]} needs to be sorted when allowOverlap={false}\"));\n    }\n}\nexports.checkInitialOverlap = checkInitialOverlap;\nfunction getMargin(element) {\n    var style = window.getComputedStyle(element);\n    return {\n        top: parseInt(style[\"margin-top\"], 10),\n        bottom: parseInt(style[\"margin-bottom\"], 10),\n        left: parseInt(style[\"margin-left\"], 10),\n        right: parseInt(style[\"margin-right\"], 10),\n    };\n}\nexports.getMargin = getMargin;\nfunction getPaddingAndBorder(element) {\n    var style = window.getComputedStyle(element);\n    return {\n        top: parseInt(style[\"padding-top\"], 10) +\n            parseInt(style[\"border-top-width\"], 10),\n        bottom: parseInt(style[\"padding-bottom\"], 10) +\n            parseInt(style[\"border-bottom-width\"], 10),\n        left: parseInt(style[\"padding-left\"], 10) +\n            parseInt(style[\"border-left-width\"], 10),\n        right: parseInt(style[\"padding-right\"], 10) +\n            parseInt(style[\"border-right-width\"], 10),\n    };\n}\nexports.getPaddingAndBorder = getPaddingAndBorder;\nfunction translateThumbs(elements, offsets, rtl) {\n    var inverter = rtl ? -1 : 1;\n    elements.forEach(function (element, index) {\n        return translate(element, inverter * offsets[index].x, offsets[index].y);\n    });\n}\nexports.translateThumbs = translateThumbs;\n/**\n * Util function for calculating the index of the thumb that is closes to a given position\n * @param thumbs - array of Thumb element to calculate the distance from\n * @param clientX - target x position (mouse/touch)\n * @param clientY - target y position (mouse/touch)\n * @param direction - the direction of the track\n */\nfunction getClosestThumbIndex(thumbs, clientX, clientY, direction) {\n    var thumbIndex = 0;\n    var minThumbDistance = getThumbDistance(thumbs[0], clientX, clientY, direction);\n    for (var i = 1; i < thumbs.length; i++) {\n        var thumbDistance = getThumbDistance(thumbs[i], clientX, clientY, direction);\n        if (thumbDistance < minThumbDistance) {\n            minThumbDistance = thumbDistance;\n            thumbIndex = i;\n        }\n    }\n    return thumbIndex;\n}\nexports.getClosestThumbIndex = getClosestThumbIndex;\nfunction translate(element, x, y) {\n    element.style.transform = \"translate(\".concat(x, \"px, \").concat(y, \"px)\");\n}\nexports.translate = translate;\n// adapted from https://github.com/alexreardon/raf-schd\nvar schd = function (fn) {\n    var lastArgs = [];\n    var frameId = null;\n    var wrapperFn = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        lastArgs = args;\n        if (frameId) {\n            return;\n        }\n        frameId = requestAnimationFrame(function () {\n            frameId = null;\n            fn.apply(void 0, lastArgs);\n        });\n    };\n    return wrapperFn;\n};\nexports.schd = schd;\nfunction replaceAt(values, index, value) {\n    var ret = values.slice(0);\n    ret[index] = value;\n    return ret;\n}\nexports.replaceAt = replaceAt;\nfunction getTrackBackground(_a) {\n    var values = _a.values, colors = _a.colors, min = _a.min, max = _a.max, _b = _a.direction, direction = _b === void 0 ? types_1.Direction.Right : _b, _c = _a.rtl, rtl = _c === void 0 ? false : _c;\n    if (rtl && direction === types_1.Direction.Right) {\n        direction = types_1.Direction.Left;\n    }\n    else if (rtl && types_1.Direction.Left) {\n        direction = types_1.Direction.Right;\n    }\n    // sort values ascending\n    var progress = values\n        .slice(0)\n        .sort(function (a, b) { return a - b; })\n        .map(function (value) { return ((value - min) / (max - min)) * 100; });\n    var middle = progress.reduce(function (acc, point, index) {\n        return \"\".concat(acc, \", \").concat(colors[index], \" \").concat(point, \"%, \").concat(colors[index + 1], \" \").concat(point, \"%\");\n    }, \"\");\n    return \"linear-gradient(\".concat(direction, \", \").concat(colors[0], \" 0%\").concat(middle, \", \").concat(colors[colors.length - 1], \" 100%)\");\n}\nexports.getTrackBackground = getTrackBackground;\nfunction voidFn() { }\nexports.voidFn = voidFn;\nfunction assertUnreachable(x) {\n    throw new Error(\"Didn't expect to get here\");\n}\nexports.assertUnreachable = assertUnreachable;\n/**\n * Util function for grabbing the true largest width of a thumb\n * including the label\n * @param thumbEl - Thumb element to grab the largest width from\n * @param value - Thumb value, not label value\n * @param separator - Label separator value\n */\nvar getThumbWidth = function (thumbEl, value, separator, decimalPlaces, valueToLabel) {\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var width = Math.ceil(__spreadArray([thumbEl], Array.from(thumbEl.children), true).reduce(function (width, el) {\n        var elWidth = Math.ceil(el.getBoundingClientRect().width);\n        /**\n         * If a label contains a merged label value, it won't return the true\n         * label width for that Thumb. Clone the label and change the value\n         * to that individual Thumb value in order to grab the true width.\n         */\n        if (el.innerText &&\n            el.innerText.includes(separator) &&\n            el.childElementCount === 0) {\n            var elClone = el.cloneNode(true);\n            elClone.innerHTML = valueToLabel(value.toFixed(decimalPlaces));\n            elClone.style.visibility = \"hidden\";\n            document.body.appendChild(elClone);\n            elWidth = Math.ceil(elClone.getBoundingClientRect().width);\n            document.body.removeChild(elClone);\n        }\n        return elWidth > width ? elWidth : width;\n    }, thumbEl.getBoundingClientRect().width));\n    return width;\n};\n/**\n * Bulk of logic for thumb overlaps\n * Consider a scenario with 5 thumbs;\n * Thumb 1 overlaps with thumb 0 and thumb 2\n * Thumb 2 overlaps with thumb 3\n * We need an array that contains [0, 1, 2, 3]\n * The function needs to return the directly overlapping thumbs\n * and all thumbs overlapping linked to those and so on\n * @param index - Thumb index calculating overlaps for\n * @param offsets - Current Array of Thumb offsets for Range\n * @param thumbs - Array of Thumb elements\n * @param values - Array of Thumb values\n * @param separator - String separator for merged label values\n * @returns overlaps - Array of all overlapping thumbs from the index\n */\nvar getOverlaps = function (index, offsets, thumbs, values, separator, decimalPlaces, valueToLabel) {\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var overlaps = [];\n    /**\n     * Recursive function for building the overlaps Array\n     * If an overlap is found, find the overlaps for that overlap\n     * @param thumbIndex current Thumb index to find overlaps from\n     */\n    var buildOverlaps = function (thumbIndex) {\n        var thumbXWidth = getThumbWidth(thumbs[thumbIndex], values[thumbIndex], separator, decimalPlaces, valueToLabel);\n        var thumbX = offsets[thumbIndex].x;\n        /**\n         * Iterate through the Thumb offsets, if there is a match\n         * add the thumbIndex and siblingIndex to the overlaps Array\n         *\n         * Then build overlaps from the overlapping siblingIndex\n         */\n        offsets.forEach(function (_a, siblingIndex) {\n            var siblingX = _a.x;\n            var siblingWidth = getThumbWidth(thumbs[siblingIndex], values[siblingIndex], separator, decimalPlaces, valueToLabel);\n            if (thumbIndex !== siblingIndex &&\n                ((thumbX >= siblingX && thumbX <= siblingX + siblingWidth) ||\n                    (thumbX + thumbXWidth >= siblingX &&\n                        thumbX + thumbXWidth <= siblingX + siblingWidth))) {\n                if (!overlaps.includes(siblingIndex)) {\n                    overlaps.push(thumbIndex);\n                    overlaps.push(siblingIndex);\n                    overlaps = __spreadArray(__spreadArray([], overlaps, true), [thumbIndex, siblingIndex], false);\n                    buildOverlaps(siblingIndex);\n                }\n            }\n        });\n    };\n    buildOverlaps(index);\n    // Sort and remove duplicates from the built overlaps\n    return Array.from(new Set(overlaps.sort()));\n};\n/**\n * A custom React Hook for calculating whether a thumb overlaps\n * another and whether labels could/should merge.\n * @param rangeRef - React ref value of Range component\n * @param values - current Range values Array\n * @param index - thumb index\n * @param step - step value, used to calculate the number of decimal places\n * @param separator - string to separate thumb values\n * @returns label value + styling for thumb label\n */\nvar useThumbOverlap = function (rangeRef, values, index, step, separator, valueToLabel) {\n    if (step === void 0) { step = 0.1; }\n    if (separator === void 0) { separator = \" - \"; }\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var decimalPlaces = (0, exports.getStepDecimals)(step);\n    // Create initial label style and value. Label value defaults to thumb value\n    var _a = (0, react_1.useState)({}), labelStyle = _a[0], setLabelStyle = _a[1];\n    var _b = (0, react_1.useState)(valueToLabel(values[index].toFixed(decimalPlaces))), labelValue = _b[0], setLabelValue = _b[1];\n    // When the rangeRef or values change, update the Thumb label values and styling\n    (0, react_1.useEffect)(function () {\n        if (rangeRef) {\n            var thumbs = rangeRef.getThumbs();\n            if (thumbs.length < 1)\n                return;\n            var newStyle = {};\n            var offsets_1 = rangeRef.getOffsets();\n            /**\n             * Get any overlaps for the given Thumb index. This must return all linked\n             * Thumbs. So if there are 4 Thumbs and Thumbs 2, 3 and 4 overlap. If we are\n             * getting the overlaps for Thumb 1 and it overlaps only Thumb 2, we must get\n             * 2, 3 and 4 also.\n             */\n            var overlaps = getOverlaps(index, offsets_1, thumbs, values, separator, decimalPlaces, valueToLabel);\n            // Set a default label value of the Thumb value\n            var labelValue_1 = valueToLabel(values[index].toFixed(decimalPlaces));\n            /**\n             * If there are overlaps for the Thumb, we need to calculate the correct\n             * Label value along with the relevant styling. We only want to show a Label\n             * for the left most Thumb in an overlapping set.\n             * All other Thumbs will be set to display: none.\n             */\n            if (overlaps.length) {\n                /**\n                 * Get an Array of the offsets for the overlapping Thumbs\n                 * This is so we can determine if the Thumb we are looking at\n                 * is the left most thumb in an overlapping set\n                 */\n                var offsetsX = overlaps.reduce(function (a, c, i, s) {\n                    return a.length ? __spreadArray(__spreadArray([], a, true), [offsets_1[s[i]].x], false) : [offsets_1[s[i]].x];\n                }, []);\n                /**\n                 * If our Thumb is the left most Thumb, we can build a Label value\n                 * and set the style for that Label\n                 */\n                if (Math.min.apply(Math, offsetsX) === offsets_1[index].x) {\n                    /**\n                     * First calculate the Label value. To do this,\n                     * grab all the values for the Thumbs in our overlaps.\n                     * Then convert that to a Set and sort it whilst removing duplicates.\n                     */\n                    var labelValues_1 = [];\n                    overlaps.forEach(function (thumb) {\n                        labelValues_1.push(values[thumb].toFixed(decimalPlaces));\n                    });\n                    /**\n                     *  Update the labelValue with the resulting Array\n                     *  joined by our defined separator\n                     */\n                    labelValue_1 = Array.from(new Set(labelValues_1.sort(function (a, b) { return parseFloat(a) - parseFloat(b); })))\n                        .map(valueToLabel)\n                        .join(separator);\n                    /**\n                     * Lastly, build the label styling. The label styling will\n                     * position the label and apply a transform so that it's centered.\n                     * We want the center point between the left edge of the left most Thumb\n                     * and the right edge of the right most Thumb.\n                     */\n                    var first = Math.min.apply(Math, offsetsX);\n                    var last = Math.max.apply(Math, offsetsX);\n                    var lastWidth = thumbs[overlaps[offsetsX.indexOf(last)]].getBoundingClientRect()\n                        .width;\n                    newStyle.left = \"\".concat(Math.abs(first - (last + lastWidth)) / 2, \"px\");\n                    newStyle.transform = \"translate(-50%, 0)\";\n                }\n                else {\n                    // If the Thumb isn't the left most Thumb, hide the Label!\n                    newStyle.visibility = \"hidden\";\n                }\n            }\n            // Update the label value and style\n            setLabelValue(labelValue_1);\n            setLabelStyle(newStyle);\n        }\n    }, [rangeRef, values]);\n    return [labelValue, labelStyle];\n};\nexports.useThumbOverlap = useThumbOverlap;\n/**\n * Util function for calculating the distance of the center of a thumb\n * form a given mouse/touch target's position\n * @param thumbEl - Thumb element to calculate the distance from\n * @param clientX - target x position (mouse/touch)\n * @param clientY - target y position (mouse/touch)\n * @param direction - the direction of the track\n */\nfunction getThumbDistance(thumbEl, clientX, clientY, direction) {\n    var _a = thumbEl.getBoundingClientRect(), left = _a.left, top = _a.top, width = _a.width, height = _a.height;\n    return isVertical(direction)\n        ? Math.abs(clientY - (top + height / 2))\n        : Math.abs(clientX - (left + width / 2));\n}\nvar isIOS = function () {\n    var _a;\n    // @ts-ignore\n    var platform = ((_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.platform) || navigator.platform;\n    return ([\n        \"iPad Simulator\",\n        \"iPhone Simulator\",\n        \"iPod Simulator\",\n        \"iPad\",\n        \"iPhone\",\n        \"iPod\",\n    ].includes(platform) ||\n        // iPad on iOS 13 detection\n        (navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document));\n};\nexports.isIOS = isIOS;\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,aAAa,GAAI,IAAI,IAAI,IAAI,CAACA,aAAa,IAAK,UAAUC,EAAE,EAAEC,IAAI,EAAEC,IAAI,EAAE;EAC1E,IAAIA,IAAI,IAAIC,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,IAAI,CAACG,MAAM,EAAEG,EAAE,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;IACjF,IAAIE,EAAE,IAAI,EAAEF,CAAC,IAAIJ,IAAI,CAAC,EAAE;MACpB,IAAI,CAACM,EAAE,EAAEA,EAAE,GAAGC,KAAK,CAACC,SAAS,CAACC,KAAK,CAACC,IAAI,CAACV,IAAI,EAAE,CAAC,EAAEI,CAAC,CAAC;MACpDE,EAAE,CAACF,CAAC,CAAC,GAAGJ,IAAI,CAACI,CAAC,CAAC;IACnB;EACJ;EACA,OAAOL,EAAE,CAACY,MAAM,CAACL,EAAE,IAAIC,KAAK,CAACC,SAAS,CAACC,KAAK,CAACC,IAAI,CAACV,IAAI,CAAC,CAAC;AAC5D,CAAC;AACDY,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,KAAK,GAAGF,OAAO,CAACG,eAAe,GAAGH,OAAO,CAACI,iBAAiB,GAAGJ,OAAO,CAACK,MAAM,GAAGL,OAAO,CAACM,kBAAkB,GAAGN,OAAO,CAACO,SAAS,GAAGP,OAAO,CAACQ,IAAI,GAAGR,OAAO,CAACS,SAAS,GAAGT,OAAO,CAACU,oBAAoB,GAAGV,OAAO,CAACW,eAAe,GAAGX,OAAO,CAACY,mBAAmB,GAAGZ,OAAO,CAACa,SAAS,GAAGb,OAAO,CAACc,mBAAmB,GAAGd,OAAO,CAACe,4BAA4B,GAAGf,OAAO,CAACgB,eAAe,GAAGhB,OAAO,CAACiB,UAAU,GAAGjB,OAAO,CAACkB,aAAa,GAAGlB,OAAO,CAACmB,cAAc,GAAGnB,OAAO,CAACoB,eAAe,GAAGpB,OAAO,CAACqB,YAAY,GAAGrB,OAAO,CAACsB,eAAe,GAAG,KAAK,CAAC;AAC5gB,IAAIC,OAAO,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC9B,IAAIC,OAAO,GAAGD,OAAO,CAAC,SAAS,CAAC;AAChC,IAAIF,eAAe,GAAG,SAAAA,CAAUI,IAAI,EAAE;EAClC,IAAIC,QAAQ,GAAGD,IAAI,CAACE,QAAQ,CAAC,CAAC,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAC5C,OAAOF,QAAQ,GAAGA,QAAQ,CAACtC,MAAM,GAAG,CAAC;AACzC,CAAC;AACDW,OAAO,CAACsB,eAAe,GAAGA,eAAe;AACzC,SAASD,YAAYA,CAACS,KAAK,EAAE;EACzB,OAASA,KAAK,CAACC,OAAO,IAAID,KAAK,CAACC,OAAO,CAAC1C,MAAM,IACzCyC,KAAK,CAACE,cAAc,IAAIF,KAAK,CAACE,cAAc,CAAC3C,MAAO;AAC7D;AACAW,OAAO,CAACqB,YAAY,GAAGA,YAAY;AACnC,SAASD,eAAeA,CAACa,GAAG,EAAEC,GAAG,EAAER,IAAI,EAAE;EACrC,IAAIS,GAAG,GAAG,CAACD,GAAG,GAAGD,GAAG,IAAIP,IAAI;EAC5B,IAAIU,SAAS,GAAG,CAAC;EACjB,IAAIC,UAAU,GAAGC,MAAM,CAACH,GAAG,CAACI,OAAO,CAACH,SAAS,CAAC,CAAC;EAC/C,OAAOI,QAAQ,CAACH,UAAU,CAACT,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,KAAKS,UAAU;AAC7D;AACArC,OAAO,CAACoB,eAAe,GAAGA,eAAe;AACzC,SAASD,cAAcA,CAAClB,KAAK,EAAEwC,KAAK,EAAER,GAAG,EAAEC,GAAG,EAAER,IAAI,EAAEgB,YAAY,EAAEC,MAAM,EAAE;EACxE,IAAIC,OAAO,GAAG,KAAK;EACnB3C,KAAK,GAAG4C,IAAI,CAACC,KAAK,CAAC7C,KAAK,GAAG2C,OAAO,CAAC,GAAGA,OAAO;EAC7C,IAAI,CAACF,YAAY,EAAE;IACf,IAAIK,IAAI,GAAGJ,MAAM,CAACF,KAAK,GAAG,CAAC,CAAC;IAC5B,IAAIO,IAAI,GAAGL,MAAM,CAACF,KAAK,GAAG,CAAC,CAAC;IAC5B,IAAIM,IAAI,IAAIA,IAAI,GAAG9C,KAAK,EACpB,OAAO8C,IAAI;IACf,IAAIC,IAAI,IAAIA,IAAI,GAAG/C,KAAK,EACpB,OAAO+C,IAAI;EACnB;EACA,IAAI/C,KAAK,GAAGiC,GAAG,EACX,OAAOA,GAAG;EACd,IAAIjC,KAAK,GAAGgC,GAAG,EACX,OAAOA,GAAG;EACd;EACA;EACA;EACA,IAAIgB,SAAS,GAAGJ,IAAI,CAACK,KAAK,CAACjD,KAAK,GAAG2C,OAAO,GAAGX,GAAG,GAAGW,OAAO,CAAC,GAAGC,IAAI,CAACK,KAAK,CAACxB,IAAI,GAAGkB,OAAO,CAAC;EACxF,IAAIO,eAAe,GAAGN,IAAI,CAACK,KAAK,CAACjD,KAAK,GAAG2C,OAAO,GAAGC,IAAI,CAACO,GAAG,CAACH,SAAS,CAAC,CAAC;EACvE,IAAII,OAAO,GAAGJ,SAAS,KAAK,CAAC,GAAGhD,KAAK,GAAGkD,eAAe,GAAGP,OAAO;EACjE;EACA;EACA,IAAIT,GAAG,GAAGU,IAAI,CAACO,GAAG,CAACH,SAAS,GAAGL,OAAO,CAAC,GAAGlB,IAAI,GAAG,CAAC,GAAG2B,OAAO,GAAGA,OAAO,GAAG3B,IAAI;EAC7E,IAAI4B,aAAa,GAAG,CAAC,CAAC,EAAEtD,OAAO,CAACsB,eAAe,EAAEI,IAAI,CAAC;EACtD,OAAO6B,UAAU,CAACpB,GAAG,CAACI,OAAO,CAACe,aAAa,CAAC,CAAC;AACjD;AACAtD,OAAO,CAACmB,cAAc,GAAGA,cAAc;AACvC,SAASD,aAAaA,CAACjB,KAAK,EAAEgC,GAAG,EAAEC,GAAG,EAAE;EACpC,OAAO,CAACjC,KAAK,GAAGgC,GAAG,KAAKC,GAAG,GAAGD,GAAG,CAAC;AACtC;AACAjC,OAAO,CAACkB,aAAa,GAAGA,aAAa;AACrC,SAASD,UAAUA,CAACuC,SAAS,EAAE;EAC3B,OAAOA,SAAS,KAAK/B,OAAO,CAACgC,SAAS,CAACC,EAAE,IAAIF,SAAS,KAAK/B,OAAO,CAACgC,SAAS,CAACE,IAAI;AACrF;AACA3D,OAAO,CAACiB,UAAU,GAAGA,UAAU;AAC/B,SAASD,eAAeA,CAACf,KAAK,EAAEgC,GAAG,EAAEC,GAAG,EAAE;EACtC,IAAID,GAAG,IAAIC,GAAG,EAAE;IACZ,MAAM,IAAI0B,UAAU,CAAC,OAAO,CAAC/D,MAAM,CAACoC,GAAG,EAAE,8BAA8B,CAAC,CAACpC,MAAM,CAACqC,GAAG,EAAE,GAAG,CAAC,CAAC;EAC9F;EACA,IAAIjC,KAAK,GAAGgC,GAAG,EAAE;IACb,MAAM,IAAI2B,UAAU,CAAC,SAAS,CAAC/D,MAAM,CAACI,KAAK,EAAE,yBAAyB,CAAC,CAACJ,MAAM,CAACoC,GAAG,EAAE,GAAG,CAAC,CAAC;EAC7F;EACA,IAAIhC,KAAK,GAAGiC,GAAG,EAAE;IACb,MAAM,IAAI0B,UAAU,CAAC,SAAS,CAAC/D,MAAM,CAACI,KAAK,EAAE,wBAAwB,CAAC,CAACJ,MAAM,CAACqC,GAAG,EAAE,GAAG,CAAC,CAAC;EAC5F;AACJ;AACAlC,OAAO,CAACgB,eAAe,GAAGA,eAAe;AACzC,SAASD,4BAA4BA,CAACd,KAAK,EAAEgC,GAAG,EAAEC,GAAG,EAAE;EACnD,IAAIjC,KAAK,GAAGgC,GAAG,EAAE;IACb;IACA,OAAOA,GAAG;EACd;EACA,IAAIhC,KAAK,GAAGiC,GAAG,EAAE;IACb;IACA,OAAOA,GAAG;EACd,CAAC,MACI;IACD,OAAOjC,KAAK;EAChB;AACJ;AACAD,OAAO,CAACe,4BAA4B,GAAGA,4BAA4B;AACnE,SAASD,mBAAmBA,CAAC6B,MAAM,EAAE;EACjC,IAAIA,MAAM,CAACtD,MAAM,GAAG,CAAC,EACjB;EACJ,IAAI,CAACsD,MAAM,CAAChD,KAAK,CAAC,CAAC,CAAC,CAACkE,KAAK,CAAC,UAAUC,IAAI,EAAExE,CAAC,EAAE;IAAE,OAAOqD,MAAM,CAACrD,CAAC,CAAC,IAAIwE,IAAI;EAAE,CAAC,CAAC,EAAE;IAC1E,MAAM,IAAIF,UAAU,CAAC,WAAW,CAAC/D,MAAM,CAAC8C,MAAM,EAAE,iDAAiD,CAAC,CAAC;EACvG;AACJ;AACA3C,OAAO,CAACc,mBAAmB,GAAGA,mBAAmB;AACjD,SAASD,SAASA,CAACkD,OAAO,EAAE;EACxB,IAAIC,KAAK,GAAGC,MAAM,CAACC,gBAAgB,CAACH,OAAO,CAAC;EAC5C,OAAO;IACHI,GAAG,EAAE3B,QAAQ,CAACwB,KAAK,CAAC,YAAY,CAAC,EAAE,EAAE,CAAC;IACtCI,MAAM,EAAE5B,QAAQ,CAACwB,KAAK,CAAC,eAAe,CAAC,EAAE,EAAE,CAAC;IAC5CK,IAAI,EAAE7B,QAAQ,CAACwB,KAAK,CAAC,aAAa,CAAC,EAAE,EAAE,CAAC;IACxCM,KAAK,EAAE9B,QAAQ,CAACwB,KAAK,CAAC,cAAc,CAAC,EAAE,EAAE;EAC7C,CAAC;AACL;AACAhE,OAAO,CAACa,SAAS,GAAGA,SAAS;AAC7B,SAASD,mBAAmBA,CAACmD,OAAO,EAAE;EAClC,IAAIC,KAAK,GAAGC,MAAM,CAACC,gBAAgB,CAACH,OAAO,CAAC;EAC5C,OAAO;IACHI,GAAG,EAAE3B,QAAQ,CAACwB,KAAK,CAAC,aAAa,CAAC,EAAE,EAAE,CAAC,GACnCxB,QAAQ,CAACwB,KAAK,CAAC,kBAAkB,CAAC,EAAE,EAAE,CAAC;IAC3CI,MAAM,EAAE5B,QAAQ,CAACwB,KAAK,CAAC,gBAAgB,CAAC,EAAE,EAAE,CAAC,GACzCxB,QAAQ,CAACwB,KAAK,CAAC,qBAAqB,CAAC,EAAE,EAAE,CAAC;IAC9CK,IAAI,EAAE7B,QAAQ,CAACwB,KAAK,CAAC,cAAc,CAAC,EAAE,EAAE,CAAC,GACrCxB,QAAQ,CAACwB,KAAK,CAAC,mBAAmB,CAAC,EAAE,EAAE,CAAC;IAC5CM,KAAK,EAAE9B,QAAQ,CAACwB,KAAK,CAAC,eAAe,CAAC,EAAE,EAAE,CAAC,GACvCxB,QAAQ,CAACwB,KAAK,CAAC,oBAAoB,CAAC,EAAE,EAAE;EAChD,CAAC;AACL;AACAhE,OAAO,CAACY,mBAAmB,GAAGA,mBAAmB;AACjD,SAASD,eAAeA,CAAC4D,QAAQ,EAAEC,OAAO,EAAEC,GAAG,EAAE;EAC7C,IAAIC,QAAQ,GAAGD,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC;EAC3BF,QAAQ,CAACI,OAAO,CAAC,UAAUZ,OAAO,EAAEtB,KAAK,EAAE;IACvC,OAAOhC,SAAS,CAACsD,OAAO,EAAEW,QAAQ,GAAGF,OAAO,CAAC/B,KAAK,CAAC,CAACmC,CAAC,EAAEJ,OAAO,CAAC/B,KAAK,CAAC,CAACoC,CAAC,CAAC;EAC5E,CAAC,CAAC;AACN;AACA7E,OAAO,CAACW,eAAe,GAAGA,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,oBAAoBA,CAACoE,MAAM,EAAEC,OAAO,EAAEC,OAAO,EAAExB,SAAS,EAAE;EAC/D,IAAIyB,UAAU,GAAG,CAAC;EAClB,IAAIC,gBAAgB,GAAGC,gBAAgB,CAACL,MAAM,CAAC,CAAC,CAAC,EAAEC,OAAO,EAAEC,OAAO,EAAExB,SAAS,CAAC;EAC/E,KAAK,IAAIlE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwF,MAAM,CAACzF,MAAM,EAAEC,CAAC,EAAE,EAAE;IACpC,IAAI8F,aAAa,GAAGD,gBAAgB,CAACL,MAAM,CAACxF,CAAC,CAAC,EAAEyF,OAAO,EAAEC,OAAO,EAAExB,SAAS,CAAC;IAC5E,IAAI4B,aAAa,GAAGF,gBAAgB,EAAE;MAClCA,gBAAgB,GAAGE,aAAa;MAChCH,UAAU,GAAG3F,CAAC;IAClB;EACJ;EACA,OAAO2F,UAAU;AACrB;AACAjF,OAAO,CAACU,oBAAoB,GAAGA,oBAAoB;AACnD,SAASD,SAASA,CAACsD,OAAO,EAAEa,CAAC,EAAEC,CAAC,EAAE;EAC9Bd,OAAO,CAACC,KAAK,CAACqB,SAAS,GAAG,YAAY,CAACxF,MAAM,CAAC+E,CAAC,EAAE,MAAM,CAAC,CAAC/E,MAAM,CAACgF,CAAC,EAAE,KAAK,CAAC;AAC7E;AACA7E,OAAO,CAACS,SAAS,GAAGA,SAAS;AAC7B;AACA,IAAID,IAAI,GAAG,SAAAA,CAAU8E,EAAE,EAAE;EACrB,IAAIC,QAAQ,GAAG,EAAE;EACjB,IAAIC,OAAO,GAAG,IAAI;EAClB,IAAIC,SAAS,GAAG,SAAAA,CAAA,EAAY;IACxB,IAAIC,IAAI,GAAG,EAAE;IACb,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGvG,SAAS,CAACC,MAAM,EAAEsG,EAAE,EAAE,EAAE;MAC1CD,IAAI,CAACC,EAAE,CAAC,GAAGvG,SAAS,CAACuG,EAAE,CAAC;IAC5B;IACAJ,QAAQ,GAAGG,IAAI;IACf,IAAIF,OAAO,EAAE;MACT;IACJ;IACAA,OAAO,GAAGI,qBAAqB,CAAC,YAAY;MACxCJ,OAAO,GAAG,IAAI;MACdF,EAAE,CAACO,KAAK,CAAC,KAAK,CAAC,EAAEN,QAAQ,CAAC;IAC9B,CAAC,CAAC;EACN,CAAC;EACD,OAAOE,SAAS;AACpB,CAAC;AACDzF,OAAO,CAACQ,IAAI,GAAGA,IAAI;AACnB,SAASD,SAASA,CAACoC,MAAM,EAAEF,KAAK,EAAExC,KAAK,EAAE;EACrC,IAAI6F,GAAG,GAAGnD,MAAM,CAAChD,KAAK,CAAC,CAAC,CAAC;EACzBmG,GAAG,CAACrD,KAAK,CAAC,GAAGxC,KAAK;EAClB,OAAO6F,GAAG;AACd;AACA9F,OAAO,CAACO,SAAS,GAAGA,SAAS;AAC7B,SAASD,kBAAkBA,CAACyF,EAAE,EAAE;EAC5B,IAAIpD,MAAM,GAAGoD,EAAE,CAACpD,MAAM;IAAEqD,MAAM,GAAGD,EAAE,CAACC,MAAM;IAAE/D,GAAG,GAAG8D,EAAE,CAAC9D,GAAG;IAAEC,GAAG,GAAG6D,EAAE,CAAC7D,GAAG;IAAE+D,EAAE,GAAGF,EAAE,CAACvC,SAAS;IAAEA,SAAS,GAAGyC,EAAE,KAAK,KAAK,CAAC,GAAGxE,OAAO,CAACgC,SAAS,CAACyC,KAAK,GAAGD,EAAE;IAAEE,EAAE,GAAGJ,EAAE,CAACtB,GAAG;IAAEA,GAAG,GAAG0B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,GAAGA,EAAE;EAClM,IAAI1B,GAAG,IAAIjB,SAAS,KAAK/B,OAAO,CAACgC,SAAS,CAACyC,KAAK,EAAE;IAC9C1C,SAAS,GAAG/B,OAAO,CAACgC,SAAS,CAAC2C,IAAI;EACtC,CAAC,MACI,IAAI3B,GAAG,IAAIhD,OAAO,CAACgC,SAAS,CAAC2C,IAAI,EAAE;IACpC5C,SAAS,GAAG/B,OAAO,CAACgC,SAAS,CAACyC,KAAK;EACvC;EACA;EACA,IAAIG,QAAQ,GAAG1D,MAAM,CAChBhD,KAAK,CAAC,CAAC,CAAC,CACR2G,IAAI,CAAC,UAAUC,CAAC,EAAEC,CAAC,EAAE;IAAE,OAAOD,CAAC,GAAGC,CAAC;EAAE,CAAC,CAAC,CACvCC,GAAG,CAAC,UAAUxG,KAAK,EAAE;IAAE,OAAQ,CAACA,KAAK,GAAGgC,GAAG,KAAKC,GAAG,GAAGD,GAAG,CAAC,GAAI,GAAG;EAAE,CAAC,CAAC;EAC1E,IAAIyE,MAAM,GAAGL,QAAQ,CAACM,MAAM,CAAC,UAAUC,GAAG,EAAEC,KAAK,EAAEpE,KAAK,EAAE;IACtD,OAAO,EAAE,CAAC5C,MAAM,CAAC+G,GAAG,EAAE,IAAI,CAAC,CAAC/G,MAAM,CAACmG,MAAM,CAACvD,KAAK,CAAC,EAAE,GAAG,CAAC,CAAC5C,MAAM,CAACgH,KAAK,EAAE,KAAK,CAAC,CAAChH,MAAM,CAACmG,MAAM,CAACvD,KAAK,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC5C,MAAM,CAACgH,KAAK,EAAE,GAAG,CAAC;EACjI,CAAC,EAAE,EAAE,CAAC;EACN,OAAO,kBAAkB,CAAChH,MAAM,CAAC2D,SAAS,EAAE,IAAI,CAAC,CAAC3D,MAAM,CAACmG,MAAM,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAACnG,MAAM,CAAC6G,MAAM,EAAE,IAAI,CAAC,CAAC7G,MAAM,CAACmG,MAAM,CAACA,MAAM,CAAC3G,MAAM,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC;AAC/I;AACAW,OAAO,CAACM,kBAAkB,GAAGA,kBAAkB;AAC/C,SAASD,MAAMA,CAAA,EAAG,CAAE;AACpBL,OAAO,CAACK,MAAM,GAAGA,MAAM;AACvB,SAASD,iBAAiBA,CAACwE,CAAC,EAAE;EAC1B,MAAM,IAAIkC,KAAK,CAAC,2BAA2B,CAAC;AAChD;AACA9G,OAAO,CAACI,iBAAiB,GAAGA,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI2G,aAAa,GAAG,SAAAA,CAAUC,OAAO,EAAE/G,KAAK,EAAEgH,SAAS,EAAE3D,aAAa,EAAE4D,YAAY,EAAE;EAClF,IAAIA,YAAY,KAAK,KAAK,CAAC,EAAE;IAAEA,YAAY,GAAG,SAAAA,CAAUjH,KAAK,EAAE;MAAE,OAAOA,KAAK;IAAE,CAAC;EAAE;EAClF,IAAIkH,KAAK,GAAGtE,IAAI,CAACuE,IAAI,CAACpI,aAAa,CAAC,CAACgI,OAAO,CAAC,EAAEvH,KAAK,CAACP,IAAI,CAAC8H,OAAO,CAACK,QAAQ,CAAC,EAAE,IAAI,CAAC,CAACV,MAAM,CAAC,UAAUQ,KAAK,EAAEG,EAAE,EAAE;IAC3G,IAAIC,OAAO,GAAG1E,IAAI,CAACuE,IAAI,CAACE,EAAE,CAACE,qBAAqB,CAAC,CAAC,CAACL,KAAK,CAAC;IACzD;AACR;AACA;AACA;AACA;IACQ,IAAIG,EAAE,CAACG,SAAS,IACZH,EAAE,CAACG,SAAS,CAACC,QAAQ,CAACT,SAAS,CAAC,IAChCK,EAAE,CAACK,iBAAiB,KAAK,CAAC,EAAE;MAC5B,IAAIC,OAAO,GAAGN,EAAE,CAACO,SAAS,CAAC,IAAI,CAAC;MAChCD,OAAO,CAACE,SAAS,GAAGZ,YAAY,CAACjH,KAAK,CAACsC,OAAO,CAACe,aAAa,CAAC,CAAC;MAC9DsE,OAAO,CAAC5D,KAAK,CAAC+D,UAAU,GAAG,QAAQ;MACnCC,QAAQ,CAACC,IAAI,CAACC,WAAW,CAACN,OAAO,CAAC;MAClCL,OAAO,GAAG1E,IAAI,CAACuE,IAAI,CAACQ,OAAO,CAACJ,qBAAqB,CAAC,CAAC,CAACL,KAAK,CAAC;MAC1Da,QAAQ,CAACC,IAAI,CAACE,WAAW,CAACP,OAAO,CAAC;IACtC;IACA,OAAOL,OAAO,GAAGJ,KAAK,GAAGI,OAAO,GAAGJ,KAAK;EAC5C,CAAC,EAAEH,OAAO,CAACQ,qBAAqB,CAAC,CAAC,CAACL,KAAK,CAAC,CAAC;EAC1C,OAAOA,KAAK;AAChB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIiB,WAAW,GAAG,SAAAA,CAAU3F,KAAK,EAAE+B,OAAO,EAAEM,MAAM,EAAEnC,MAAM,EAAEsE,SAAS,EAAE3D,aAAa,EAAE4D,YAAY,EAAE;EAChG,IAAIA,YAAY,KAAK,KAAK,CAAC,EAAE;IAAEA,YAAY,GAAG,SAAAA,CAAUjH,KAAK,EAAE;MAAE,OAAOA,KAAK;IAAE,CAAC;EAAE;EAClF,IAAIoI,QAAQ,GAAG,EAAE;EACjB;AACJ;AACA;AACA;AACA;EACI,IAAIC,aAAa,GAAG,SAAAA,CAAUrD,UAAU,EAAE;IACtC,IAAIsD,WAAW,GAAGxB,aAAa,CAACjC,MAAM,CAACG,UAAU,CAAC,EAAEtC,MAAM,CAACsC,UAAU,CAAC,EAAEgC,SAAS,EAAE3D,aAAa,EAAE4D,YAAY,CAAC;IAC/G,IAAIsB,MAAM,GAAGhE,OAAO,CAACS,UAAU,CAAC,CAACL,CAAC;IAClC;AACR;AACA;AACA;AACA;AACA;IACQJ,OAAO,CAACG,OAAO,CAAC,UAAUoB,EAAE,EAAE0C,YAAY,EAAE;MACxC,IAAIC,QAAQ,GAAG3C,EAAE,CAACnB,CAAC;MACnB,IAAI+D,YAAY,GAAG5B,aAAa,CAACjC,MAAM,CAAC2D,YAAY,CAAC,EAAE9F,MAAM,CAAC8F,YAAY,CAAC,EAAExB,SAAS,EAAE3D,aAAa,EAAE4D,YAAY,CAAC;MACpH,IAAIjC,UAAU,KAAKwD,YAAY,KACzBD,MAAM,IAAIE,QAAQ,IAAIF,MAAM,IAAIE,QAAQ,GAAGC,YAAY,IACpDH,MAAM,GAAGD,WAAW,IAAIG,QAAQ,IAC7BF,MAAM,GAAGD,WAAW,IAAIG,QAAQ,GAAGC,YAAa,CAAC,EAAE;QAC3D,IAAI,CAACN,QAAQ,CAACX,QAAQ,CAACe,YAAY,CAAC,EAAE;UAClCJ,QAAQ,CAACO,IAAI,CAAC3D,UAAU,CAAC;UACzBoD,QAAQ,CAACO,IAAI,CAACH,YAAY,CAAC;UAC3BJ,QAAQ,GAAGrJ,aAAa,CAACA,aAAa,CAAC,EAAE,EAAEqJ,QAAQ,EAAE,IAAI,CAAC,EAAE,CAACpD,UAAU,EAAEwD,YAAY,CAAC,EAAE,KAAK,CAAC;UAC9FH,aAAa,CAACG,YAAY,CAAC;QAC/B;MACJ;IACJ,CAAC,CAAC;EACN,CAAC;EACDH,aAAa,CAAC7F,KAAK,CAAC;EACpB;EACA,OAAOhD,KAAK,CAACP,IAAI,CAAC,IAAI2J,GAAG,CAACR,QAAQ,CAAC/B,IAAI,CAAC,CAAC,CAAC,CAAC;AAC/C,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAInG,eAAe,GAAG,SAAAA,CAAU2I,QAAQ,EAAEnG,MAAM,EAAEF,KAAK,EAAEf,IAAI,EAAEuF,SAAS,EAAEC,YAAY,EAAE;EACpF,IAAIxF,IAAI,KAAK,KAAK,CAAC,EAAE;IAAEA,IAAI,GAAG,GAAG;EAAE;EACnC,IAAIuF,SAAS,KAAK,KAAK,CAAC,EAAE;IAAEA,SAAS,GAAG,KAAK;EAAE;EAC/C,IAAIC,YAAY,KAAK,KAAK,CAAC,EAAE;IAAEA,YAAY,GAAG,SAAAA,CAAUjH,KAAK,EAAE;MAAE,OAAOA,KAAK;IAAE,CAAC;EAAE;EAClF,IAAIqD,aAAa,GAAG,CAAC,CAAC,EAAEtD,OAAO,CAACsB,eAAe,EAAEI,IAAI,CAAC;EACtD;EACA,IAAIqE,EAAE,GAAG,CAAC,CAAC,EAAExE,OAAO,CAACwH,QAAQ,EAAE,CAAC,CAAC,CAAC;IAAEC,UAAU,GAAGjD,EAAE,CAAC,CAAC,CAAC;IAAEkD,aAAa,GAAGlD,EAAE,CAAC,CAAC,CAAC;EAC7E,IAAIE,EAAE,GAAG,CAAC,CAAC,EAAE1E,OAAO,CAACwH,QAAQ,EAAE7B,YAAY,CAACvE,MAAM,CAACF,KAAK,CAAC,CAACF,OAAO,CAACe,aAAa,CAAC,CAAC,CAAC;IAAE4F,UAAU,GAAGjD,EAAE,CAAC,CAAC,CAAC;IAAEkD,aAAa,GAAGlD,EAAE,CAAC,CAAC,CAAC;EAC7H;EACA,CAAC,CAAC,EAAE1E,OAAO,CAAC6H,SAAS,EAAE,YAAY;IAC/B,IAAIN,QAAQ,EAAE;MACV,IAAIhE,MAAM,GAAGgE,QAAQ,CAACO,SAAS,CAAC,CAAC;MACjC,IAAIvE,MAAM,CAACzF,MAAM,GAAG,CAAC,EACjB;MACJ,IAAIiK,QAAQ,GAAG,CAAC,CAAC;MACjB,IAAIC,SAAS,GAAGT,QAAQ,CAACU,UAAU,CAAC,CAAC;MACrC;AACZ;AACA;AACA;AACA;AACA;MACY,IAAInB,QAAQ,GAAGD,WAAW,CAAC3F,KAAK,EAAE8G,SAAS,EAAEzE,MAAM,EAAEnC,MAAM,EAAEsE,SAAS,EAAE3D,aAAa,EAAE4D,YAAY,CAAC;MACpG;MACA,IAAIuC,YAAY,GAAGvC,YAAY,CAACvE,MAAM,CAACF,KAAK,CAAC,CAACF,OAAO,CAACe,aAAa,CAAC,CAAC;MACrE;AACZ;AACA;AACA;AACA;AACA;MACY,IAAI+E,QAAQ,CAAChJ,MAAM,EAAE;QACjB;AAChB;AACA;AACA;AACA;QACgB,IAAIqK,QAAQ,GAAGrB,QAAQ,CAAC1B,MAAM,CAAC,UAAUJ,CAAC,EAAEoD,CAAC,EAAErK,CAAC,EAAEsK,CAAC,EAAE;UACjD,OAAOrD,CAAC,CAAClH,MAAM,GAAGL,aAAa,CAACA,aAAa,CAAC,EAAE,EAAEuH,CAAC,EAAE,IAAI,CAAC,EAAE,CAACgD,SAAS,CAACK,CAAC,CAACtK,CAAC,CAAC,CAAC,CAACsF,CAAC,CAAC,EAAE,KAAK,CAAC,GAAG,CAAC2E,SAAS,CAACK,CAAC,CAACtK,CAAC,CAAC,CAAC,CAACsF,CAAC,CAAC;QACjH,CAAC,EAAE,EAAE,CAAC;QACN;AAChB;AACA;AACA;QACgB,IAAI/B,IAAI,CAACZ,GAAG,CAAC4D,KAAK,CAAChD,IAAI,EAAE6G,QAAQ,CAAC,KAAKH,SAAS,CAAC9G,KAAK,CAAC,CAACmC,CAAC,EAAE;UACvD;AACpB;AACA;AACA;AACA;UACoB,IAAIiF,aAAa,GAAG,EAAE;UACtBxB,QAAQ,CAAC1D,OAAO,CAAC,UAAUmF,KAAK,EAAE;YAC9BD,aAAa,CAACjB,IAAI,CAACjG,MAAM,CAACmH,KAAK,CAAC,CAACvH,OAAO,CAACe,aAAa,CAAC,CAAC;UAC5D,CAAC,CAAC;UACF;AACpB;AACA;AACA;UACoBmG,YAAY,GAAGhK,KAAK,CAACP,IAAI,CAAC,IAAI2J,GAAG,CAACgB,aAAa,CAACvD,IAAI,CAAC,UAAUC,CAAC,EAAEC,CAAC,EAAE;YAAE,OAAOjD,UAAU,CAACgD,CAAC,CAAC,GAAGhD,UAAU,CAACiD,CAAC,CAAC;UAAE,CAAC,CAAC,CAAC,CAAC,CAC5GC,GAAG,CAACS,YAAY,CAAC,CACjB6C,IAAI,CAAC9C,SAAS,CAAC;UACpB;AACpB;AACA;AACA;AACA;AACA;UACoB,IAAI+C,KAAK,GAAGnH,IAAI,CAACZ,GAAG,CAAC4D,KAAK,CAAChD,IAAI,EAAE6G,QAAQ,CAAC;UAC1C,IAAIO,IAAI,GAAGpH,IAAI,CAACX,GAAG,CAAC2D,KAAK,CAAChD,IAAI,EAAE6G,QAAQ,CAAC;UACzC,IAAIQ,SAAS,GAAGpF,MAAM,CAACuD,QAAQ,CAACqB,QAAQ,CAACS,OAAO,CAACF,IAAI,CAAC,CAAC,CAAC,CAACzC,qBAAqB,CAAC,CAAC,CAC3EL,KAAK;UACVmC,QAAQ,CAACjF,IAAI,GAAG,EAAE,CAACxE,MAAM,CAACgD,IAAI,CAACO,GAAG,CAAC4G,KAAK,IAAIC,IAAI,GAAGC,SAAS,CAAC,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC;UACzEZ,QAAQ,CAACjE,SAAS,GAAG,oBAAoB;QAC7C,CAAC,MACI;UACD;UACAiE,QAAQ,CAACvB,UAAU,GAAG,QAAQ;QAClC;MACJ;MACA;MACAoB,aAAa,CAACM,YAAY,CAAC;MAC3BR,aAAa,CAACK,QAAQ,CAAC;IAC3B;EACJ,CAAC,EAAE,CAACR,QAAQ,EAAEnG,MAAM,CAAC,CAAC;EACtB,OAAO,CAACuG,UAAU,EAAEF,UAAU,CAAC;AACnC,CAAC;AACDhJ,OAAO,CAACG,eAAe,GAAGA,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASgF,gBAAgBA,CAAC6B,OAAO,EAAEjC,OAAO,EAAEC,OAAO,EAAExB,SAAS,EAAE;EAC5D,IAAIuC,EAAE,GAAGiB,OAAO,CAACQ,qBAAqB,CAAC,CAAC;IAAEnD,IAAI,GAAG0B,EAAE,CAAC1B,IAAI;IAAEF,GAAG,GAAG4B,EAAE,CAAC5B,GAAG;IAAEgD,KAAK,GAAGpB,EAAE,CAACoB,KAAK;IAAEiD,MAAM,GAAGrE,EAAE,CAACqE,MAAM;EAC5G,OAAOnJ,UAAU,CAACuC,SAAS,CAAC,GACtBX,IAAI,CAACO,GAAG,CAAC4B,OAAO,IAAIb,GAAG,GAAGiG,MAAM,GAAG,CAAC,CAAC,CAAC,GACtCvH,IAAI,CAACO,GAAG,CAAC2B,OAAO,IAAIV,IAAI,GAAG8C,KAAK,GAAG,CAAC,CAAC,CAAC;AAChD;AACA,IAAIjH,KAAK,GAAG,SAAAA,CAAA,EAAY;EACpB,IAAI6F,EAAE;EACN;EACA,IAAIsE,QAAQ,GAAG,CAAC,CAACtE,EAAE,GAAGuE,SAAS,CAACC,aAAa,MAAM,IAAI,IAAIxE,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACsE,QAAQ,KAAKC,SAAS,CAACD,QAAQ;EACtH,OAAQ,CACJ,gBAAgB,EAChB,kBAAkB,EAClB,gBAAgB,EAChB,MAAM,EACN,QAAQ,EACR,MAAM,CACT,CAAC3C,QAAQ,CAAC2C,QAAQ,CAAC;EAChB;EACCC,SAAS,CAACE,SAAS,CAAC9C,QAAQ,CAAC,KAAK,CAAC,IAAI,YAAY,IAAIM,QAAS;AACzE,CAAC;AACDhI,OAAO,CAACE,KAAK,GAAGA,KAAK","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}